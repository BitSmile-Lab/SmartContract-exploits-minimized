// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test, console2} from "forge-std/Test.sol";
import {MissingAccessControls} from "../../src/missing-access-controls/MissingAccessControls.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IWETH{
   function balanceOf(address) external view returns (uint256);
   function deposit() external payable;
}


contract MissingAccessControlsTest is Test {
    MissingAccessControls public missingAccessControls;
    IWETH public iweth;
    IERC20 public dai;
    event Transfer(address indexed from,  address indexed to, uint256 amount);

    function setUp() public {
        missingAccessControls = new MissingAccessControls();
        iweth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
        dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
        
    }

    function test_anyoneCanSetOwner(address randomOwner) public {
        missingAccessControls.setOwner(randomOwner);
        assertEq(missingAccessControls.owner(), randomOwner);
    }

    function testfail_SetOwnerOnlyOwner(address randomOwner) public{
        vm.expectRevert(bytes("not the owner!"));

        vm.prank(address(1));
        missingAccessControls.setOwnerOnlyOwner(randomOwner);
    }

    function test2Revert() public{
        vm.expectRevert(MissingAccessControls.NotAuthorized.selector);
        missingAccessControls.throwErrors();
    }

    function testEmit() public{
        vm.expectEmit(true, true, false, false);

        emit Transfer(address(this), address(111), 222);
        missingAccessControls.transferToken(address(this), address(111), 223);
    }

    function testTrnasferMany() public{
        address[] memory froms = new address[](2);
        froms[0] = address(this);
        froms[1] = address(this);

        address[] memory tos = new address[](2);
        tos[0] = address(111);
        tos[1] = address(222);

        uint256[] memory amounts = new uint256[](2);
        amounts[0] = 123;
        amounts[1] = 456;
        for(uint256 i=0; i<froms.length;i++){
            vm.expectEmit(true, true, false, true);
            emit Transfer(froms[i], tos[i], amounts[i]);
        }
        missingAccessControls.transferMany(froms, tos, amounts);

    }

    function testTimestamp() public{
        uint256 t = block.timestamp;
        skip(1 hours);
        console2.log("the time now", block.timestamp);
        assertEq(block.timestamp, t+ 1 hours);
        vm.warp(t + 1 days);
        console2.log("the time now", block.timestamp);
    }

    function testDeal() public{
        deal(address(2), 1 ether);
        assertEq(address(2).balance, 1 ether);
    }

    function testSignature() public{
        (address owner, uint256 ownerkey) =  makeAddrAndKey("Owner");
        string memory message = "I want a dollor";
        bytes32 message_to_sign = keccak256(abi.encode(message));
        (uint8 v, bytes32 r, bytes32 s) =  vm.sign(ownerkey, message_to_sign); 

        address signer = ecrecover(message_to_sign, v, r, s);
        assertEq(owner, signer);
    }

    function testForkWeth() public{
        uint256 balanceBefore = iweth.balanceOf(address(this));
        console2.log("this address balanceBefore is :", balanceBefore);

        iweth.deposit{value: 1 ether}();

        uint256 balanceAfter = iweth.balanceOf(address(this));
        console2.log("this address balanceAfter is :", balanceAfter);
    }

    function testSetOneMillionDai() public{
        address alice = makeAddr("Alice");
        console2.log("alice address balance before is :", dai.balanceOf(alice));
        console2.log("dai total supply before is :", dai.totalSupply());

        deal(address(dai), alice, 1 ether, true);

        console2.log("alice address balance after is :", dai.balanceOf(alice));
        console2.log("dai total supply after is :", dai.totalSupply());
    }
    
}
