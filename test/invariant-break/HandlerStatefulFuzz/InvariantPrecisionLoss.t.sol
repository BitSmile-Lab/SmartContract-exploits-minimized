// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {PrecisionLoss} from "../../../src/invariant-break/PrecisionLoss.sol";
import {InvariantPrecisionLossHandler} from "./InvariantPrecisionLossHandler.sol";

import {console2} from "forge-std/console2.sol";
import {Test} from "forge-std/Test.sol";

contract InvariantPrecisionLossTest is Test {
    // real contract
    PrecisionLoss  internal _underlying;
    // handler which exposes real contract
    InvariantPrecisionLossHandler internal _handler;

    function setUp() public {
        _underlying = new PrecisionLoss();
        _handler    = new InvariantPrecisionLossHandler(_underlying);

        // invariant fuzz targets _handler contract
        targetContract(address(_handler));

        // functions to target during invariant tests
        bytes4[] memory selectors = new bytes4[](1);
        selectors[0] = _handler.ussdAmountToBuy.selector;

        targetSelector(FuzzSelector({
            addr: address(_handler),
            selectors: selectors
        }));
    }

    // invariant: original output not 0. We want to see if
    // there is a set of inputs where the original equation
    // originalOutput == 0 but the simplified equation > 0
    // Setting this invariant makes foundry try to break it 
    // which dramatically increases the efficiency of the fuzz test
    function invariant_originalOutputNotZero() public view {
        assert(_handler.originalOutput() != 0);
    }
}
