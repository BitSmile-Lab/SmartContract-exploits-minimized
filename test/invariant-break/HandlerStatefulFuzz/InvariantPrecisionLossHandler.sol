// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {PrecisionLoss} from "../../../src/invariant-break/PrecisionLoss.sol";

import {console2} from "forge-std/console2.sol";
import {CommonBase} from "forge-std/Base.sol";
import {StdUtils} from "forge-std/StdUtils.sol";

contract InvariantPrecisionLossHandler is CommonBase, StdUtils {
    // real contract being tested
    PrecisionLoss internal _underlying;

    // invariant variables, set to 1 as the invariant will
    // be errorOutput != 0, so don't want it to fail immediately 
    uint public originalOutput   = 1;
    uint public simplifiedOutput = 1;

    // optimized finding variables
    uint public maxPrecisionLoss;
    uint public mplUssdAmount;
    uint public mplDaiAmount;

    constructor(PrecisionLoss underlying) {
        _underlying = underlying;
    }

    // function that will be called during invariant fuzz tests
    function ussdAmountToBuy(uint uusdAmount, uint daiAmount) public {
        // constrain inputs between $1 & $1B in their respective 
        // precision ranges
        uusdAmount = bound(uusdAmount, 1e6 , 1000000000e6 );
        daiAmount  = bound(daiAmount , 1e18, 1000000000e18);

        // requirement of the functions being tested
        vm.assume(uusdAmount > daiAmount/1e12);

        // run both original & simplified functions
        originalOutput   = _underlying.ussdOriginalAmountToBuy(uusdAmount, daiAmount);
        simplifiedOutput = _underlying.ussdSimplifiedAmountToBuy(uusdAmount, daiAmount);

        // find the difference in precision loss
        uint precisionLoss = simplifiedOutput - originalOutput;

        //
        // if this run produced greater precision loss than all 
        // previous, or if the precision loss was the same AND 
        // originalOutput == 0 AND simplifiedOutput > 0, then save it 
        // & its inputs
        //
        // we are really interested in seeing if we can reach a state
        // where originalOutput == 0 && simplifiedOutput > 0 as this 
        // is a more damaging form of precision loss
        //
        // could also optimize for lowest uusdAmount & daiAmount 
        // required to produce the precision loss.
        //
        if(precisionLoss > 0) {
            if(precisionLoss > maxPrecisionLoss || 
                (precisionLoss == maxPrecisionLoss 
              && originalOutput == 0 && simplifiedOutput > 0)) {
                maxPrecisionLoss = precisionLoss;
                mplUssdAmount    = uusdAmount;
                mplDaiAmount     = daiAmount;

                console2.log("originalOutput   : ", originalOutput);
                console2.log("simplifiedOutput : ", simplifiedOutput);
                console2.log("maxPrecisionLoss : ", maxPrecisionLoss);
                console2.log("mplUssdAmount    : ", mplUssdAmount);
                console2.log("mplDaiAmount     : ", mplDaiAmount);
            }            
        }

    }
}
