// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";

import {WETH9} from "../mocks/WETH9.sol";
import {AddressSet, LibAddressSet} from "./AddressSet.sol";
import {MockUsers} from "../mocks/MockUsers.sol";

contract WETH9Handler is Test, MockUsers{
    using LibAddressSet for AddressSet;

    WETH9 public weth;
    uint256 public total_deposit;
    uint256 public total_withdraw;

    uint256 public constant TOTAL_ETH = 123_000_000 ether;
     constructor(WETH9 _weth) MockUsers(10)  {
        weth = _weth;
        deal(address(this), TOTAL_ETH);

    
    }

    function deposit(uint256 actorSeed, uint256 amount) useRandomActor(actorSeed) public {

        amount = bound(amount, 0, address(this).balance);
        _pay(currentActor, amount);

        // uint256 balance = address(this).balance;
        // amount = bound(amount, 0, balance);
        total_deposit += amount;
        vm.prank(currentActor);
        weth.deposit{value: amount}();
    }

    function withdraw(uint256 actorSeed, uint256 amount)useRandomActor(actorSeed) public{
        amount = bound(amount, 0, weth.balanceOf(currentActor));
        
        total_withdraw += amount;
        vm.startPrank(currentActor);
        weth.withdraw(amount);
        _pay(address(this), amount);
        vm.stopPrank();

    }

     function sendFallBack(uint256 actorSeed, uint256 amount) useRandomActor(actorSeed) public{
       amount = bound(amount, 0, address(this).balance);
        _pay(currentActor, amount);

        total_deposit += amount;
        vm.prank(currentActor);
        _pay(address(weth), amount);
               
    }

    receive() external payable{

    }

    function _pay(address to, uint256 amount) internal {
        (bool s,) = to.call{value: amount}("");
        require(s, "pay() failed");
    }

   
}